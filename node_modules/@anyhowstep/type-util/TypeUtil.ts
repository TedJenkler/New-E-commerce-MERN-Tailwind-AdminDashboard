import {Optional} from "./Optional";

export class TypeUtil {
    public static Check<T> (x : T) : T {
        return x;
    }

    public static Coalesce<T> (arg0 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, arg2 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, arg2 : Optional<T>, arg3 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, arg2 : Optional<T>, arg3 : Optional<T>, arg4 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, arg2 : Optional<T>, arg3 : Optional<T>, arg4 : Optional<T>, arg5 : Optional<T>, def : T) : T;
    public static Coalesce<T> (arg0 : Optional<T>, arg1 : Optional<T>, arg2 : Optional<T>, arg3 : Optional<T>, arg4 : Optional<T>, arg5 : Optional<T>, arg6 : Optional<T>, def : T) : T;
    public static Coalesce<T> (...args : Optional<T>[]) : T|undefined {
        for (let i of args) {
            if (i != null) {
                return i;
            }
        }
        return undefined;
    }

    public static ToPromise<T> (v : T|Promise<T>) : Promise<T> {
        if (v instanceof Promise) {
            return v;
        } else {
            return Promise.resolve(v);
        }
    }
}
